<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktiver Lese-Trainer</title>
    <style>
        /* CSS bleibt unverändert - hier zur Vollständigkeit gekürzt */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        #app-container { background-color: #ffffff; padding: 25px 30px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 700px; text-align: center; }
        h1, h2 { color: #333; }
        .view { display: none; }
        .view.active { display: block; }
        #list-selection-container { margin-top: 20px; text-align: left; }
        .list-item { background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px 20px; margin-bottom: 12px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
        .list-item:hover { background-color: #e9ecef; border-color: #ced4da; }
        .list-item h3 { margin: 0 0 5px 0; color: #007bff; }
        .list-item p { margin: 0; color: #6c757d; font-size: 0.9rem; }
        #loading-indicator { font-style: italic; color: #666; }
        #progress-indicator { font-size: 0.9rem; color: #777; margin-bottom: 20px; }
        #current-reconstruction { min-height: 50px; border: 2px dashed #d0d0d0; border-radius: 8px; padding: 15px; margin: 20px 0; font-size: 1.2rem; color: #333; font-weight: bold; letter-spacing: 1px; background-color: #fafafa; }
        #word-pool { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 20px; }
        #feedback-message { margin-top: 15px; font-weight: bold; min-height: 24px; }
        #feedback-message.correct { color: #28a745; }
        #feedback-message.incorrect { color: #dc3545; }
        button { padding: 12px 20px; font-size: 1rem; cursor: pointer; border: none; border-radius: 5px; background-color: #007bff; color: white; transition: background-color 0.2s; }
        button:hover:not(:disabled) { background-color: #0056b3; }
        button:disabled { background-color: #e0e0e0; cursor: not-allowed; color: #999; }
        .word-button { background-color: #6c757d; }
        .word-button:hover:not(:disabled) { background-color: #5a6268; }
        #play-audio-button { background-color: #17a2b8; margin-right: 10px; }
        #next-sentence-button { background-color: #28a745; display: none; }
        .menu-button { background-color: #6c757d; margin-top: 20px; }

        /* NEUER CSS FÜR DEN TOGGLE SWITCH */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            vertical-align: middle; /* Align with label */
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }
        input:checked + .slider {
            background-color: #2196F3;
        }
        input:focus + .slider {
            box-shadow: 0 0 1px #2196F3;
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }
        .slider.round:before {
            border-radius: 50%;
        }
        #error-type-selection label {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between radio and text */
            margin-bottom: 5px;
            font-size: 0.95rem;
            color: #444;
        }
        #error-type-selection input[type="radio"] {
            margin: 0; /* Remove default margin for better alignment */
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1>Interaktiver Lese-Trainer</h1>

        <!-- Start-Ansicht -->
        <div id="start-view" class="view active">
            <h2>Wähle eine Satzliste zum Üben</h2>
            <div id="list-selection-container">
                <p id="loading-indicator">Lade Listen...</p>
            </div>

            <!-- NEUER BEREICH FÜR FEHLER-MODUS -->
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0; text-align: left;">
                <h3>Fehler-Modus (Optional)</h3>
                <label class="switch">
                    <input type="checkbox" id="error-mode-toggle">
                    <span class="slider round"></span>
                </label>
                <label for="error-mode-toggle" style="margin-left: 10px; font-weight: bold; vertical-align: middle;">Fehler aktivieren</label>

                <div id="error-type-selection" style="display: none; margin-top: 15px;">
                    <h4>Fehlerart auswählen:</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label><input type="radio" name="errorType" value="missingLetter"> Buchstabe fehlt (z. B. Tisch → Tsch)</label>
                        <label><input type="radio" name="errorType" value="swappedLetters"> Buchstaben vertauscht (z. B. Maus → Muas)</label>
                        <label><input type="radio" name="errorType" value="replacedLetter"> Falscher Buchstabe ersetzt (z. B. Ball → Balt)</label>
                        <label><input type="radio" name="errorType" value="duplicatedLetters"> Doppelte Buchstaben eingefügt (z. B. Schule → Schulle)</label>
                        <label><input type="radio" name="errorType" value="phoneticallySimilar"> Phonetisch ähnliche Buchstaben (z. B. Fisch → Visch)</label>
                        <label><input type="radio" name="errorType" value="capitalization"> Groß-/Kleinschreibung: Anfangsbuchstaben verändert (z. B. Katze → katze)</label>
                    </div>
                </div>
            </div>
            <!-- ENDE NEUER BEREICH FÜR FEHLER-MODUS -->
        </div>

        <!-- Spiel-Ansicht -->
        <div id="game-view" class="view">
            <div id="progress-indicator">Satz 1 von X</div>
            <p>Höre gut zu und baue den Satz nach.</p>
            <div id="current-reconstruction">&nbsp;</div>
            <div id="word-pool"></div>
            <div id="feedback-message"></div>
            <button id="play-audio-button">Satz vorlesen</button>
            <button id="next-sentence-button">Nächster Satz</button>
            <br>
            <button id="back-to-menu-button-game" class="menu-button">Zurück zum Menü</button>
        </div>

        <!-- Finish-Ansicht -->
        <div id="finish-view" class="view">
            <h2>Großartig!</h2>
            <p>Du hast alle Sätze erfolgreich geübt.</p>
            <button id="restart-button">Dieselbe Liste nochmal</button>
            <button id="back-to-menu-button-finish" class="menu-button">Andere Liste wählen</button>
        </div>
    </div>

    <script>
        // DOM-Elemente
        const startView = document.getElementById('start-view');
        const gameView = document.getElementById('game-view');
        const finishView = document.getElementById('finish-view');
        const listSelectionContainer = document.getElementById('list-selection-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const progressIndicator = document.getElementById('progress-indicator');
        const currentReconstruction = document.getElementById('current-reconstruction');
        const wordPool = document.getElementById('word-pool');
        const feedbackMessage = document.getElementById('feedback-message');
        const playAudioButton = document.getElementById('play-audio-button');
        const nextSentenceButton = document.getElementById('next-sentence-button');
        const restartButton = document.getElementById('restart-button');
        const backToMenuGameBtn = document.getElementById('back-to-menu-button-game');
        const backToMenuFinishBtn = document.getElementById('back-to-menu-button-finish');
        
        // NEUE DOM-ELEMENTE FÜR FEHLER-MODUS
        const errorModeToggle = document.getElementById('error-mode-toggle');
        const errorTypeSelection = document.getElementById('error-type-selection');
        const errorTypeRadios = document.querySelectorAll('input[name="errorType"]');
        
        // Spielzustand
        let allSentences = [];
        let currentSentenceIndex = 0;
        let originalWords = []; // Enthält immer die korrekten Wörter für den Vergleich
        let reconstructedWords = [];
        let germanVoice = null;

        // NEUE SPIELZUSTÄNDE FÜR FEHLER-MODUS
        let errorModeEnabled = false;
        let selectedErrorType = null; // Speichert den Wert des ausgewählten Radio-Buttons


        // --- Initialisierung und Navigation ---

        // Event Listener
        document.addEventListener('DOMContentLoaded', loadMasterList);
        backToMenuGameBtn.addEventListener('click', showStartView);
        backToMenuFinishBtn.addEventListener('click', showStartView);
        restartButton.addEventListener('click', () => startGame(allSentences));
        playAudioButton.addEventListener('click', playCurrentSentence);
        nextSentenceButton.addEventListener('click', loadNextSentence);

        // NEUE EVENT LISTENER FÜR FEHLER-MODUS
        errorModeToggle.addEventListener('change', () => {
            errorModeEnabled = errorModeToggle.checked;
            errorTypeSelection.style.display = errorModeEnabled ? 'block' : 'none';
            // Wenn der Fehler-Modus deaktiviert wird, Zustand zurücksetzen
            if (!errorModeEnabled) {
                selectedErrorType = null;
                errorTypeRadios.forEach(radio => radio.checked = false);
            }
        });

        errorTypeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                selectedErrorType = event.target.value;
            });
        });

        function showView(viewToShow) {
            document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
            viewToShow.classList.add('active');
        }

        function showStartView() {
            allSentences = [];
            currentSentenceIndex = 0;
            // Fehler-Modus UI und Zustand zurücksetzen, wenn ins Menü zurückgekehrt wird
            errorModeEnabled = false;
            selectedErrorType = null;
            errorModeToggle.checked = false;
            errorTypeSelection.style.display = 'none';
            errorTypeRadios.forEach(radio => radio.checked = false);
            showView(startView);
        }

        // --- Laden der Daten (unverändert) ---

        async function loadMasterList() {
            try {
                const response = await fetch('master.json');
                if (!response.ok) throw new Error('Netzwerkfehler beim Laden der master.json');
                const data = await response.json();
                populateListSelection(data.lists);
            } catch (error) {
                console.error("Fehler:", error);
                loadingIndicator.textContent = 'Fehler beim Laden der Satzlisten.';
            }
        }

        function populateListSelection(lists) {
            listSelectionContainer.innerHTML = '';
            lists.forEach(list => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.dataset.file = list.file;
                item.innerHTML = `<h3>${list.title}</h3><p>${list.description}</p>`;
                item.addEventListener('click', async () => {
                    try {
                        const response = await fetch(list.file);
                        if (!response.ok) throw new Error(`Datei ${list.file} nicht gefunden.`);
                        const sentenceData = await response.json();
                        startGame(sentenceData.sentences);
                    } catch (error) {
                        alert(`Fehler beim Laden der Satzliste: ${error.message}`);
                    }
                });
                listSelectionContainer.appendChild(item);
            });
        }

        // --- Spiellogik (mit Fehler-Modus Anpassung) ---
        
        function startGame(sentences) {
            if (!sentences || sentences.length === 0) {
                alert('Diese Liste enthält keine Sätze.');
                return;
            }
            // Prüfen, ob Fehler-Modus aktiviert ist, aber keine Fehlerart ausgewählt wurde
            if (errorModeEnabled && !selectedErrorType) {
                alert('Bitte wählen Sie eine Fehlerart aus, um den Fehler-Modus zu starten.');
                return;
            }

            allSentences = sentences;
            currentSentenceIndex = 0;
            showView(gameView);
            loadSentence(currentSentenceIndex);
        }

        function loadSentence(index) {
            if (index >= allSentences.length) {
                showView(finishView);
                return;
            }
            reconstructedWords = [];
            feedbackMessage.textContent = '';
            feedbackMessage.className = '';
            nextSentenceButton.style.display = 'none';
            updateReconstructionDisplay();
            progressIndicator.textContent = `Satz ${index + 1} von ${allSentences.length}`;

            const currentSentence = allSentences[index];
            // originalWords enthält immer die korrekten Wörter für den Vergleich
            originalWords = currentSentence.replace(/[.,!?;]$/, '').split(' ');

            let wordsForPool = []; // Dieser Array wird die Wörter für den Pool enthalten

            // FEHLER GENERIERUNG HIER
            if (errorModeEnabled && selectedErrorType) {
                const numWords = originalWords.length;
                // Maximum 30% der Wörter, aber nicht mehr als 3 Fehler pro Satz
                const maxErrors = Math.min(Math.ceil(numWords * 0.3), 3); 
                // Mindestens 1 Fehler, maximal `maxErrors`
                const numErrors = maxErrors > 0 ? (Math.floor(Math.random() * maxErrors) + 1) : 0; 

                let errorIndices = new Set();
                while (errorIndices.size < numErrors && errorIndices.size < numWords) {
                    errorIndices.add(Math.floor(Math.random() * numWords));
                }
                
                originalWords.forEach((word, idx) => {
                    wordsForPool.push(word); // Füge IMMER das korrekte Wort hinzu
                    if (errorIndices.has(idx)) {
                        const errorWord = generateError(word, selectedErrorType);
                        // Füge das fehlerhafte Wort NUR hinzu, wenn es sich vom Original unterscheidet
                        if (errorWord !== word) {
                            wordsForPool.push(errorWord);
                        }
                    }
                });
            } else {
                // Wenn kein Fehler-Modus, einfach alle originalen Wörter in den Pool legen
                wordsForPool = [...originalWords];
            }

            const shuffledWords = [...wordsForPool].sort(() => Math.random() - 0.5);
            displayWords(shuffledWords);
            playCurrentSentence();
        }
        
        // HILFSFUNKTION FÜR FEHLERGENERIERUNG
        function generateError(word, errorType) {
            // Für sehr kurze Wörter (<2 Zeichen), überspringen wir bestimmte Fehlertypen,
            // da sie sonst zu leeren oder bedeutungslosen Wörtern führen könnten.
            // Groß-/Kleinschreibung kann auch bei einem Zeichen angewendet werden.
            // Bei Wörtern mit nur einem Buchstaben kann 'missingLetter' oder 'swappedLetters' nicht sinnvoll angewendet werden.
            // 'duplicatedLetters' oder 'replacedLetter' können funktionieren.
            if (word.length <= 1 && !['capitalization', 'replacedLetter', 'duplicatedLetters'].includes(errorType)) {
                return word;
            }

            let modifiedWord = word;
            let chars = word.split('');

            // Hilfsfunktion, um die Groß-/Kleinschreibung des ursprünglichen Zeichens beizubehalten
            const preserveCase = (originalChar, newChar) => {
                if (!originalChar) return newChar; // Falls originalChar leer ist (z.B. nach Entfernen)
                if (originalChar === originalChar.toUpperCase() && originalChar.match(/[A-ZÄÖÜ]/)) {
                    return newChar.toUpperCase();
                }
                return newChar.toLowerCase();
            };

            switch (errorType) {
                case 'missingLetter': // Buchstabe fehlt (z. B. Tisch → Tsch)
                    if (chars.length > 1) { 
                        const indexToRemove = Math.floor(Math.random() * chars.length);
                        chars.splice(indexToRemove, 1);
                        modifiedWord = chars.join('');
                    }
                    break;
                case 'swappedLetters': // Buchstaben vertauscht (z. B. Maus → Muas)
                    if (chars.length > 1) { 
                        const index1 = Math.floor(Math.random() * (chars.length - 1));
                        const index2 = index1 + 1;
                        [chars[index1], chars[index2]] = [chars[index2], chars[index1]];
                        modifiedWord = chars.join('');
                    }
                    break;
                case 'replacedLetter': // Falscher Buchstabe ersetzt (z. B. Ball → Balt)
                    if (chars.length > 0) {
                        const indexToReplace = Math.floor(Math.random() * chars.length);
                        const originalChar = chars[indexToReplace].toLowerCase();
                        const alphabet = 'abcdefghijklmnopqrstuvwxyzäöüß'; 
                        let replacementChar = originalChar;
                        let attempts = 0;
                        while (replacementChar === originalChar && attempts < 10) { // Sicherstellen, dass es ein anderer Buchstabe ist
                            replacementChar = alphabet[Math.floor(Math.random() * alphabet.length)];
                            attempts++;
                        }
                        chars[indexToReplace] = preserveCase(chars[indexToReplace], replacementChar);
                        modifiedWord = chars.join('');
                    }
                    break;
                case 'duplicatedLetters': // Doppelte Buchstaben eingefügt (z. B. Schule → Schulle)
                    if (chars.length > 0) {
                        const indexToDuplicate = Math.floor(Math.random() * chars.length);
                        chars.splice(indexToDuplicate, 0, chars[indexToDuplicate]);
                        modifiedWord = chars.join('');
                    }
                    break;
                case 'phoneticallySimilar': // Phonetisch ähnliche Buchstaben (z. B. Fisch → Visch)
                    const phoneticSubstitutions = {
                        'b': ['p'], 'p': ['b'],
                        'd': ['t'], 't': ['d'],
                        'g': ['k'], 'k': ['g'],
                        'f': ['v'], 'v': ['f'],
                        's': ['z'], 'z': ['s'],
                        'eu': ['äu'], 'äu': ['eu'], // Beispiel für Diphthong
                        'ei': ['ai'], 'ai': ['ei'],
                        'sch': ['ch'], 'ch': ['sch'] // Beispiel für Mehrfachbuchstaben
                    };

                    let replaced = false;
                    // Versuche zuerst, Mehrfachbuchstaben zu ersetzen
                    const multiCharSubKeys = Object.keys(phoneticSubstitutions).filter(k => k.length > 1).sort((a, b) => b.length - a.length); // Längere zuerst
                    for (const subKey of multiCharSubKeys) {
                        const idx = word.toLowerCase().indexOf(subKey);
                        if (idx !== -1) {
                            const subs = phoneticSubstitutions[subKey];
                            const newSub = subs[Math.floor(Math.random() * subs.length)];
                            modifiedWord = word.substring(0, idx) + preserveCase(word.substring(idx, idx + subKey.length), newSub) + word.substring(idx + subKey.length);
                            replaced = true;
                            break;
                        }
                    }

                    if (!replaced) { // Wenn keine Mehrfachbuchstaben ersetzt wurden, versuche einzelne
                        for (let i = 0; i < chars.length; i++) {
                            const charLower = chars[i].toLowerCase();
                            if (phoneticSubstitutions[charLower]) {
                                const subs = phoneticSubstitutions[charLower];
                                const newChar = subs[Math.floor(Math.random() * subs.length)];
                                chars[i] = preserveCase(chars[i], newChar);
                                replaced = true;
                                break; 
                            }
                        }
                        if (replaced) modifiedWord = chars.join('');
                    }
                    
                    if (!replaced && word.length > 0) {
                        // Fallback: Wenn keine spezifische phonetische Substitution gefunden wird, versuche replacedLetter
                        return generateError(word, 'replacedLetter');
                    }
                    break;
                case 'capitalization': // Groß- und Kleinschreibung: Anfangsbuchstaben verändert (z. B. Katze → katze)
                    if (chars.length > 0 && chars[0].match(/[A-Za-zÄÖÜäöü]/)) { // Nur wenn das erste Zeichen ein Buchstabe ist
                        if (chars[0] === chars[0].toUpperCase()) {
                            chars[0] = chars[0].toLowerCase();
                        } else {
                            chars[0] = chars[0].toUpperCase();
                        }
                        modifiedWord = chars.join('');
                    }
                    break;
            }

            // Sicherstellen, dass sich das Wort tatsächlich geändert hat, um triviale "Fehler" zu vermeiden
            // und dass der Fehler nicht zu einem leeren String führt (außer bei missingLetter für 1-Buchstabe-Wörter)
            if (modifiedWord === word || (modifiedWord === "" && errorType !== 'missingLetter')) {
                 // Wenn der Fehler nicht funktioniert hat oder zu leerem String führte,
                 // versuchen wir einen einfachen replacedLetter als Fallback,
                 // es sei denn, der Fehler war bereits replacedLetter.
                if (word.length > 0 && errorType !== 'replacedLetter') {
                     return generateError(word, 'replacedLetter');
                }
                return word; // Wenn auch Fallback nicht möglich, Originalwort zurückgeben
            }
            return modifiedWord;
        }


        // Die folgenden Funktionen bleiben unverändert, da sie mit der neuen Logik kompatibel sind.
        function displayWords(words) { wordPool.innerHTML = ''; words.forEach(word => { const button = document.createElement('button'); button.textContent = word; button.classList.add('word-button'); button.addEventListener('click', () => handleWordClick(word, button)); wordPool.appendChild(button); }); }
        function handleWordClick(word, button) { button.disabled = true; reconstructedWords.push(word); updateReconstructionDisplay(); checkSentence(); }
        function updateReconstructionDisplay() { currentReconstruction.textContent = reconstructedWords.length > 0 ? reconstructedWords.join(' ') : '\u00A0'; }
        
        function checkSentence() { 
            const reconstructed = reconstructedWords.join(' '); 
            // Wichtig: `originalWords` enthält immer die korrekten Wörter für den Vergleich
            const original = originalWords.slice(0, reconstructedWords.length).join(' '); 
            
            if (reconstructed !== original) { 
                feedbackMessage.textContent = 'Das war nicht richtig. Versuch es nochmal!'; 
                feedbackMessage.className = 'incorrect'; 
                setTimeout(() => { 
                    reconstructedWords = []; 
                    updateReconstructionDisplay(); 
                    feedbackMessage.textContent = ''; 
                    document.querySelectorAll('.word-button').forEach(btn => btn.disabled = false); 
                }, 1500); 
            } else if (reconstructedWords.length === originalWords.length) { 
                feedbackMessage.textContent = 'Super, das ist richtig!'; 
                feedbackMessage.className = 'correct'; 
                nextSentenceButton.style.display = 'inline-block'; 
            } 
        }

        function loadNextSentence() { currentSentenceIndex++; loadSentence(currentSentenceIndex); }

        // --- Sprachausgabe (unverändert) ---
        
        window.speechSynthesis.onvoiceschanged = () => {
            const voices = window.speechSynthesis.getVoices();
            germanVoice = voices.find(voice => voice.name === 'Google Deutsch' && voice.lang === 'de-DE') || voices.find(voice => voice.lang === 'de-DE');
        };
        function playCurrentSentence() { if ('speechSynthesis' in window && allSentences.length > 0) { const utterance = new SpeechSynthesisUtterance(allSentences[currentSentenceIndex]); utterance.lang = 'de-DE'; utterance.rate = 0.9; if (germanVoice) utterance.voice = germanVoice; window.speechSynthesis.cancel(); window.speechSynthesis.speak(utterance); } }
    </script>
</body>
</html>
